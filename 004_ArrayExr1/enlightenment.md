# 새롭게 알게 된 내용

## javascritp

- 개념적으로 이해했어도 자주 사용해야 필요할 때 바로바로 사용 가능해짐을 느꼈다

### filter

- .filter( x => 필터 내용) 의 모양으로 사용
- 원본 배열에 영향 없이 새로운 배열 반환
- 통과한 것만 배열에 들어감

### map

- .map( x => 처리 내용 ) 의 모양으로 사용
- 원본 배열에 영향 없이 새로운 배열 반환
- 모든 요소가 처리를 거쳐 배열에 들어감

### sort

- .sort((a, b) => a.year > b.year ? 1 : -1) 의 모양으로 사용
- 원본 배열에 영향을 주고 새로운 배열도 반환
- 오름차순 내림차순이 헷갈리기 쉬움
- 버블 정렬이 일어난다
- 의미 적으론 a,b를 비교하여 true면 1이 되고 양수이므로 자리를 바꾸게 된다  
(작은 값이 앞으로 자리를 바꾸는 방식)

### reduce

> 개인적으로 개념을 공부하면서 작성했던 내용에  
> 부족한 점을 알게 되었다

- .reduce((누적, 요소) => { 내용 return 내용 }, 초기값);
- 누적
  - 첫 작동시 누적은 초기값이 된다
  - 첫 작동의 return 내용이 다음 작동의 누적값이 된다
- 하나의 값을 반환하나 그 값은 객체일 수도 있다
  - 초기값에 {}를 주고 객체에 내용을 추가해가는 경우

> 초기값이 없으면 요소와 다음 요소가 들어온다

### split

> 배열은 slice로 잘라낸다면 문자열은 split

- '문자, 열'.split(', ') 처럼 사용
- [문자, 열] 이라는 배열이 반환
- 구조분해할당으로 사용가능
  - const [text1, text2] = 문자를담은변수.split(', ');


## 기타

### console.table

- 매번 console.log만 썼는데 테이블 형태로 보는 것도 가능

### 헷갈렸던 코드

- 초기값이 객체라 객체가 반환된다
- {}의 키로 b를 사용함으로 b가 몇 번 들어오나 확인 가능
- 계속 {}에 키와 값이 들어가는 형태라 편리

```javascript
const z = data.reduce(function(a,b){
      if (!a[b]) {
        a[b] = 0;
      }
      a[b]++;
      return a
    }, {});
```
